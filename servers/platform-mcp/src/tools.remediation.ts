// servers/platform-mcp/src/tools.remediation.ts
import type { ToolDef } from "mcp-http";
import { z } from "zod";
import { mcpJson, mcpText, pendingPlanText } from "./lib/runtime.js";
import { getPolicyDoc } from "@platform/governance-core";

type CallFn = (name: string, args: any) => Promise<any>;

function firstJsonBlock(r: any) {
  if (Array.isArray(r?.content)) {
    for (const c of r.content) {
      if (c?.type === "json" && c?.json != null) return c.json;
    }
  }
  return r?.json ?? r;
}

// Hardcoded fallbacks if YAML does not provide a remediation mapping
function builtinRule(finding: any) {
  const f = finding || {};
  const meta = f.meta || {};
  switch (f.code) {
    case "APP_TLS_MIN_BELOW_1_2":
      return {
        title: "Set TLS minimum 1.2 and HTTPS-only",
        tool: "platform.harden_webapp_minimums",
        args: {
          resourceGroupName: meta.resourceGroupName,
          name: meta.webAppName,
          location: meta.location
        }
      };
    case "APP_MSI_DISABLED":
      return {
        title: "Enable system assigned identity (MSI) on Web App",
        tool: "platform.enable_webapp_identity",
        args: {
          resourceGroupName: meta.resourceGroupName,
          name: meta.webAppName,
          location: meta.location
        }
      };
    case "APP_DIAG_NO_LAW":
      return {
        title: "Enable diagnostics to Log Analytics",
        tool: "azure.enable_appservice_diagnostics_to_law",
        args: {
          resourceGroupName: meta.resourceGroupName,
          name: meta.webAppName,
          workspaceResourceGroup: meta.workspaceResourceGroup ?? meta.resourceGroupName,
          workspaceName: meta.lawName
        }
      };
    case "KV_PUBLIC_NETWORK_ENABLED":
      return {
        title: "Restrict Key Vault public network (disable)",
        tool: "azure.update_key_vault_network",
        args: {
          resourceGroupName: meta.resourceGroupName,
          name: meta.keyVaultName,
          publicNetworkAccess: "Disabled"
        }
      };
    default:
      return null;
  }
}

// Pull a remediation mapping from governance-core YAML if present
function remediationFromYaml(finding: any) {
  const doc = getPolicyDoc();
  const code = finding?.code;
  if (!code) return null;

  // Convention: doc.ato.remediations[CODE] = { title, tool, argsTemplate }
  // argsTemplate can reference meta.* via {{meta.webAppName}} etc.
  const rem = doc?.ato?.remediations?.[code];
  if (!rem?.tool) return null;

  const meta = finding?.meta || {};
  const args: any = {};
  // Simple `{{meta.key}}` interpolation
  for (const [k, v] of Object.entries(rem.args ?? {})) {
    if (typeof v === "string") {
      const m = v.match(/^{{\s*meta\.([a-zA-Z0-9_]+)\s*}}$/);
      if (m) {
        args[k] = meta[m[1]];
      } else {
        args[k] = v;
      }
    } else {
      args[k] = v;
    }
  }
  return {
    title: rem.title || `Apply ${code}`,
    tool: rem.tool,
    args
  };
}

// Prefer YAML mapping; fall back to builtin
function pickRemedy(finding: any) {
  return remediationFromYaml(finding) || builtinRule(finding);
}

export function makeRemediationTools(call: CallFn): ToolDef[] {
  const generate_plan: ToolDef = {
    name: "platform.generate_remediation_plan",
    description:
      "Turn scan findings into a sequenced set of @platform/@azure follow-ups. Returns a `steps[]` plan.",
    inputSchema: z.object({
      findings: z.array(z.any())
    }).strict(),
    handler: async (a: any) => {
      const steps = (a.findings || [])
        .map(pickRemedy)
        .filter(Boolean) as Array<{ title: string; tool: string; args: any }>;

      return {
        content: [
          ...mcpJson({ status: "done", plan: { steps } }),
          ...mcpText(
            [
              "### Remediation Plan",
              ...steps.map(
                (s, i) =>
                  `${i + 1}. **${s.title}** → \`${s.tool}\`\n   ` +
                  `@platform ${s.tool.startsWith("platform.") ? s.tool.split(".")[1] : s.tool} ${Object.entries(s.args)
                    .map(([k, v]) => `${k} ${typeof v === "string" ? `"${v}"` : JSON.stringify(v)}`)
                    .join(" ")} confirm true`
              )
            ].join("\n")
          )
        ]
      };
    }
  };

  const apply_plan: ToolDef = {
    name: "platform.apply_remediation_plan",
    description:
      "Execute a remediation plan generated by platform.generate_remediation_plan. Steps may target platform.* or azure.* tools.",
    inputSchema: z.object({
      steps: z.array(
        z.object({
          title: z.string().optional(),
          tool: z.string(),
          args: z.any()
        }).strict()
      ),
      stopOnError: z.boolean().default(true),
      confirm: z.boolean().default(false)
    }).strict(),
    handler: async (a: any) => {
      const bullets = a.steps.map((s: any, i: number) => `${i + 1}. ${s.title ?? s.tool}`);
      if (!a.confirm) {
        return {
          content: [
            ...mcpJson({ status: "pending", plan: { action: "platform.apply_remediation_plan", payload: a, mode: "review" } }),
            ...mcpText(
              pendingPlanText({
                title: "platform.apply_remediation_plan",
                bullets,
                followup: `@platform apply_remediation_plan steps ${JSON.stringify(a.steps)} confirm true`
              })
            )
          ]
        };
      }

      const results: any[] = [];
      for (const step of a.steps) {
        const res = await call(step.tool, step.args);
        const rj = firstJsonBlock(res);
        results.push({ step, result: rj, ok: !res?.isError });
        if (res?.isError && a.stopOnError) {
          return {
            content: [
              ...mcpJson({ status: "error", failedStep: step, result: rj, partial: results }),
              ...mcpText(`❌ platform.apply_remediation_plan — failed on step ${step.title ?? step.tool}`)
            ],
            isError: true
          };
        }
      }

      return {
        content: [
          ...mcpJson({ status: "done", results }),
          ...mcpText(`✅ platform.apply_remediation_plan — done.`)
        ]
      };
    }
  };

  return [generate_plan, apply_plan];
}
